%!TEX root = ../report.tex
\chapter{Related Work}
\label{cha:related_work}
\section{Keyword search on graphs}
Keyword search on RDF graphs often follows a set of common strategies. One method is to find nodes containing one or more keyword, then following the edges from the nodes to explore the graph, and find subgraphs where the combined nodes contain as many keywords as possible while also spreading as little as possible. BLINKS \citep{blinks} propose such a method, in combination with indexing and cost balancing for expanding clusters of accessed nodes. A similar approach is used by the authors in \citep{Elbassuoni:2011:KSO:2063576.2063615} where each node has an associated document containing terms from the triple. When querying the keywords are matched with these documents, creating lists based on the matching keywords, and a subgraph is constructed by joining matches from different lists.

Another strategy for keyword search in RDF graphs is to infer triples from the query. One such query system is used in AquaLog \citep{aqualog}. This method processes the input into a triple based representation, based on a linguistic model, and then further processes the triplets into what they call ``query triples.'' Creating structured queries through inference is also done in \citep{4812421}. Here the query is first used to find nodes containing some part of the query, then the graph is explored to find a connection between the nodes. The result is a series of subgraphs connecting nodes that contain part of the query. Each of the subgraphs are in turn used to create a conjunctive query with edges mapped to predicates, and nodes to subjects or objects.

Ranking and scoring the results of a search is also needed for evaluating the different methods and algorithms. A common element for ranking the results is to look at the span of the subgraphs or trees returned from the search. The shorter distance between all nodes, the more accurate a result should be. Of the above mentioned papers, three \citep{blinks, Elbassuoni:2011:KSO:2063576.2063615, 4812421} use some form of minimum spanning tree or graph when scoring or ranking the results. In addition to the minimum spanning graph, the results can be ranked by other factors. 

BLINKS adds a scoring system where shared vertices are counted multiple time, once for each node connected to it. This is done to score trees with nodes close to the root higher than nodes further away, even if the further nodes have many shared edges. The content of the nodes are also scored based on an IR style TF/IDF method. In the paper by \cite{Elbassuoni:2011:KSO:2063576.2063615} the minimum tree are ranked by a probabilistic model, and a language model. The probabilistic model scores a result based on the average probability for a term to occur in a triple in the subgraph. In addition, the language model is used to score some keywords higher based on what part of the triple they are found in. This triple scoring is done by weighting words based on the structure of the triples they are found in, so keywords that occur more often in predicates are scored higher if they are found in a predicate. The final paper, \cite{4812421}, adds popularity, and keyword matching to the minimum spanning graph. Popularity is calculated based on how many edges a node has, so that the more connected a node is, the less cost a path through that node has. The keyword matching score is based on keyword matches in a node, but is also weighted based on syntactic and semantic similarity, which is in turn done by using WordNet data.

\section{Spatial search on RDF graphs}
Keyword searching and ranking spatial RDF graphs is quite similar to regular RDF keyword searching. \cite{Shi:2016:TRS:2882903.2882941} outlines methods that incorporates spatial data into the search. These methods is similar to some of those previously mentioned here \citep{4812421, Elbassuoni:2011:KSO:2063576.2063615}. The most substantial difference is the use of R-trees to index the spatial dimension of the graph. This is done so that a subgraph can be rooted both at a real point in the world, and nodes in the graph close to the real world point. The root is used as a point for traversing the graph, and like the previous methods, the goal is to find a minimum subgraphs. The subgraphs are ranked based on how close the root node is to the selected point, the size of the tree, and how well the result tree fits the query words.

\section{Temporal search on RDF graphs}
Using the syntax specification for RDF \cite{beckett2004rdf} it is possible to declare dates as literals. Using such literals dates and times can be connected to any vertex using a user defined predicate. This makes it easy to add time and date data to any graph, but some problems arise \cite{tappolet2009applied}. When adding time with user defined predicates, semantics can be lost. A predicate such as ``borneOnDate'' denotes a start date for a human, but cannot be used as a start date for other concepts. It is possible to remedy this by attaching a concept such as ``startDate'' to the predicate, but this has the drawback of complicating the structure.

Proposals for temporal temporal RDF standards have been made. ...\\

\glsresetall